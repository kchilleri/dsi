<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sql API documentation</title>
<meta name="description" content="© 2023. Triad National Security, LLC. All rights reserved.
This program was produced under U.S. Government contract 89233218CNA000001 for Los Alamos
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sql</code></h1>
</header>
<section id="section-intro">
<p>© 2023. Triad National Security, LLC. All rights reserved.
This program was produced under U.S. Government contract 89233218CNA000001 for Los Alamos
National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S.
Department of Energy/National Nuclear Security Administration. All rights in the program are
reserved by Triad National Security, LLC, and the U.S. Department of Energy/National Nuclear
Security Administration. The Government is granted for itself and others acting on its behalf a
nonexclusive, paid-up, irrevocable worldwide license in this material to reproduce, prepare
derivative works, distribute copies to the public, perform publicly and display publicly, and to permit
others to do so.</p>
<p><strong>dsi.sql</strong> is the abstraction layer that enables a sqlite backend database for metadata.
Sets of generic helper functions are included throughout this dsi module.</p>
<p><code>isVerbose</code>: boolean if true enables printing of raw SQL queries alongside helpful logging outputs
when helper functions are called</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/user/bin/python
&#34;&#34;&#34;
© 2023. Triad National Security, LLC. All rights reserved.
This program was produced under U.S. Government contract 89233218CNA000001 for Los Alamos
National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S.
Department of Energy/National Nuclear Security Administration. All rights in the program are
reserved by Triad National Security, LLC, and the U.S. Department of Energy/National Nuclear
Security Administration. The Government is granted for itself and others acting on its behalf a
nonexclusive, paid-up, irrevocable worldwide license in this material to reproduce, prepare
derivative works, distribute copies to the public, perform publicly and display publicly, and to permit
others to do so.

**dsi.sql** is the abstraction layer that enables a sqlite backend database for metadata. 
Sets of generic helper functions are included throughout this dsi module.

`isVerbose`: boolean if true enables printing of raw SQL queries alongside helpful logging outputs
                when helper functions are called

&#34;&#34;&#34;
import sys
import os
import sqlite3
import csv

isVerbose = 0

class SQLstore(object):
    &#34;&#34;&#34; 
    Class that drives Sql query interface with DSI workflow 
    This class will declare store types and SQL initialization
    and interface
    &#34;&#34;&#34;

    filename = &#34;database.db&#34;
    types = None
    con = None
    cur = None

    def __init__(self, filename):
        &#34;&#34;&#34;
        Initiliazation function that establishes connection to a SQLite database.

        `filename`: file path to the location of the sqlite database on disk.

        `return`: none
        &#34;&#34;&#34;
        self.filename = filename
        self.con = sqlite3.connect(filename)
        self.cur = self.con.cursor()

    # Adds columns to table and their types
    def put_artifact_type(self,types):
        &#34;&#34;&#34;
        Primary function for defining metadata artifact schema.

        `types`: data_type derived class that defines the string name, properties (named SQL type), and units for each column in the schema

        `return`: none
        &#34;&#34;&#34;
        str_query = &#34;CREATE TABLE IF NOT EXISTS &#34; + str(types.name) + &#34; ( &#34;
        for key, value in types.properties.items():
            str_query = str_query + str(key) + &#34; &#34; + str(value)
            str_query = str_query +  &#34;,&#34;

        str_query = str_query.rstrip(&#39;,&#39;)
        str_query = str_query + &#34; )&#34;

        if isVerbose:
            print(str_query)
        
        self.cur.execute(str_query)
        self.con.commit()

        self.types = types

    # Adds rows to the columns defined previously
    def put_artifacts(self,artifacts):
        &#34;&#34;&#34;
        Primary function for insertion of artifact metadata into a defined schema

        `artifacts`: data_type derived class that has a regular structure of a defined schema, filled with rows to insert.

        `return`: none
        &#34;&#34;&#34;
        str_query = &#34;INSERT INTO &#34; + str(self.types.name) + &#34; VALUES ( &#34;
        for key, value in artifacts.properties.items():
            if key == &#39;file&#39;: # Todo, use this to detect str type
                str_query = str_query + &#34; &#39;&#34; + str(value) +&#34;&#39; &#34;
            else:
                str_query = str_query + &#34; &#34; + str(value)

            str_query = str_query +  &#34;,&#34;

        str_query = str_query.rstrip(&#39;,&#39;)
        str_query = str_query + &#34; )&#34;

        if isVerbose:
            print(str_query)
        
        self.cur.execute(str_query)
        self.con.commit()

    # Adds columns and rows automaticallly based on a csv file
    def put_artifacts_csv(self, fname, tname):
        &#34;&#34;&#34;
        Function for insertion of artifact metadata into a defined schema by using a CSV file, where the first row of the CSV
        contains the column names of the schema. Any rows thereafter contain data to be inserted.

        `fname`: filepath to the .csv file to be read and inserted into the database

        `tname`: String name of the table to be inserted

        `return`: none
        &#34;&#34;&#34;
        if isVerbose:
            print(&#34;Opening &#34; + fname)

        with open(fname) as csv_file:
            csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)
            line_count = 0
            for row in csv_reader:
                if line_count == 0:
                    str_query = &#34;CREATE TABLE IF NOT EXISTS &#34; + str(tname) + &#34; ( &#34;
                    for column in row:
                        str_query = str_query + str(column) + &#34; VARCHAR &#34;
                        str_query = str_query +  &#34;,&#34;

                    str_query = str_query.rstrip(&#39;,&#39;)
                    str_query = str_query + &#34; )&#34;

                    if isVerbose:
                        print(str_query)
                    
                    self.cur.execute(str_query)
                    self.con.commit()
                    line_count += 1
                else:
                    str_query = &#34;INSERT INTO &#34; + str(tname) + &#34; VALUES ( &#34;
                    for column in row:
                        str_query = str_query + &#34; &#39;&#34; + str(column) + &#34;&#39;&#34;
                        str_query = str_query +  &#34;,&#34;

                    str_query = str_query.rstrip(&#39;,&#39;)
                    str_query = str_query + &#34; )&#34;

                    if isVerbose:
                        print(str_query)
                    
                    self.cur.execute(str_query)
                    self.con.commit()
                    line_count += 1

            if isVerbose:        
                print(&#34;Read &#34; + str(line_count) + &#34; rows.&#34;)

    # Returns results from query
    def get_artifacts(self,query):
        &#34;&#34;&#34;
        Sample function to query contents of the database.
        &#34;&#34;&#34;
        print(&#34;test&#34;)

    # Closes connection to server
    def close(self):
        &#34;&#34;&#34;
        Function to manually close the connection to the sqlite server.
        &#34;&#34;&#34;
        self.con.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sql.SQLstore"><code class="flex name class">
<span>class <span class="ident">SQLstore</span></span>
<span>(</span><span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that drives Sql query interface with DSI workflow
This class will declare store types and SQL initialization
and interface</p>
<p>Initiliazation function that establishes connection to a SQLite database.</p>
<p><code>filename</code>: file path to the location of the sqlite database on disk.</p>
<p><code>return</code>: none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SQLstore(object):
    &#34;&#34;&#34; 
    Class that drives Sql query interface with DSI workflow 
    This class will declare store types and SQL initialization
    and interface
    &#34;&#34;&#34;

    filename = &#34;database.db&#34;
    types = None
    con = None
    cur = None

    def __init__(self, filename):
        &#34;&#34;&#34;
        Initiliazation function that establishes connection to a SQLite database.

        `filename`: file path to the location of the sqlite database on disk.

        `return`: none
        &#34;&#34;&#34;
        self.filename = filename
        self.con = sqlite3.connect(filename)
        self.cur = self.con.cursor()

    # Adds columns to table and their types
    def put_artifact_type(self,types):
        &#34;&#34;&#34;
        Primary function for defining metadata artifact schema.

        `types`: data_type derived class that defines the string name, properties (named SQL type), and units for each column in the schema

        `return`: none
        &#34;&#34;&#34;
        str_query = &#34;CREATE TABLE IF NOT EXISTS &#34; + str(types.name) + &#34; ( &#34;
        for key, value in types.properties.items():
            str_query = str_query + str(key) + &#34; &#34; + str(value)
            str_query = str_query +  &#34;,&#34;

        str_query = str_query.rstrip(&#39;,&#39;)
        str_query = str_query + &#34; )&#34;

        if isVerbose:
            print(str_query)
        
        self.cur.execute(str_query)
        self.con.commit()

        self.types = types

    # Adds rows to the columns defined previously
    def put_artifacts(self,artifacts):
        &#34;&#34;&#34;
        Primary function for insertion of artifact metadata into a defined schema

        `artifacts`: data_type derived class that has a regular structure of a defined schema, filled with rows to insert.

        `return`: none
        &#34;&#34;&#34;
        str_query = &#34;INSERT INTO &#34; + str(self.types.name) + &#34; VALUES ( &#34;
        for key, value in artifacts.properties.items():
            if key == &#39;file&#39;: # Todo, use this to detect str type
                str_query = str_query + &#34; &#39;&#34; + str(value) +&#34;&#39; &#34;
            else:
                str_query = str_query + &#34; &#34; + str(value)

            str_query = str_query +  &#34;,&#34;

        str_query = str_query.rstrip(&#39;,&#39;)
        str_query = str_query + &#34; )&#34;

        if isVerbose:
            print(str_query)
        
        self.cur.execute(str_query)
        self.con.commit()

    # Adds columns and rows automaticallly based on a csv file
    def put_artifacts_csv(self, fname, tname):
        &#34;&#34;&#34;
        Function for insertion of artifact metadata into a defined schema by using a CSV file, where the first row of the CSV
        contains the column names of the schema. Any rows thereafter contain data to be inserted.

        `fname`: filepath to the .csv file to be read and inserted into the database

        `tname`: String name of the table to be inserted

        `return`: none
        &#34;&#34;&#34;
        if isVerbose:
            print(&#34;Opening &#34; + fname)

        with open(fname) as csv_file:
            csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)
            line_count = 0
            for row in csv_reader:
                if line_count == 0:
                    str_query = &#34;CREATE TABLE IF NOT EXISTS &#34; + str(tname) + &#34; ( &#34;
                    for column in row:
                        str_query = str_query + str(column) + &#34; VARCHAR &#34;
                        str_query = str_query +  &#34;,&#34;

                    str_query = str_query.rstrip(&#39;,&#39;)
                    str_query = str_query + &#34; )&#34;

                    if isVerbose:
                        print(str_query)
                    
                    self.cur.execute(str_query)
                    self.con.commit()
                    line_count += 1
                else:
                    str_query = &#34;INSERT INTO &#34; + str(tname) + &#34; VALUES ( &#34;
                    for column in row:
                        str_query = str_query + &#34; &#39;&#34; + str(column) + &#34;&#39;&#34;
                        str_query = str_query +  &#34;,&#34;

                    str_query = str_query.rstrip(&#39;,&#39;)
                    str_query = str_query + &#34; )&#34;

                    if isVerbose:
                        print(str_query)
                    
                    self.cur.execute(str_query)
                    self.con.commit()
                    line_count += 1

            if isVerbose:        
                print(&#34;Read &#34; + str(line_count) + &#34; rows.&#34;)

    # Returns results from query
    def get_artifacts(self,query):
        &#34;&#34;&#34;
        Sample function to query contents of the database.
        &#34;&#34;&#34;
        print(&#34;test&#34;)

    # Closes connection to server
    def close(self):
        &#34;&#34;&#34;
        Function to manually close the connection to the sqlite server.
        &#34;&#34;&#34;
        self.con.close()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="sql.SQLstore.con"><code class="name">var <span class="ident">con</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sql.SQLstore.cur"><code class="name">var <span class="ident">cur</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sql.SQLstore.filename"><code class="name">var <span class="ident">filename</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sql.SQLstore.types"><code class="name">var <span class="ident">types</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sql.SQLstore.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to manually close the connection to the sqlite server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Function to manually close the connection to the sqlite server.
    &#34;&#34;&#34;
    self.con.close()</code></pre>
</details>
</dd>
<dt id="sql.SQLstore.get_artifacts"><code class="name flex">
<span>def <span class="ident">get_artifacts</span></span>(<span>self, query)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample function to query contents of the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_artifacts(self,query):
    &#34;&#34;&#34;
    Sample function to query contents of the database.
    &#34;&#34;&#34;
    print(&#34;test&#34;)</code></pre>
</details>
</dd>
<dt id="sql.SQLstore.put_artifact_type"><code class="name flex">
<span>def <span class="ident">put_artifact_type</span></span>(<span>self, types)</span>
</code></dt>
<dd>
<div class="desc"><p>Primary function for defining metadata artifact schema.</p>
<p><code>types</code>: data_type derived class that defines the string name, properties (named SQL type), and units for each column in the schema</p>
<p><code>return</code>: none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_artifact_type(self,types):
    &#34;&#34;&#34;
    Primary function for defining metadata artifact schema.

    `types`: data_type derived class that defines the string name, properties (named SQL type), and units for each column in the schema

    `return`: none
    &#34;&#34;&#34;
    str_query = &#34;CREATE TABLE IF NOT EXISTS &#34; + str(types.name) + &#34; ( &#34;
    for key, value in types.properties.items():
        str_query = str_query + str(key) + &#34; &#34; + str(value)
        str_query = str_query +  &#34;,&#34;

    str_query = str_query.rstrip(&#39;,&#39;)
    str_query = str_query + &#34; )&#34;

    if isVerbose:
        print(str_query)
    
    self.cur.execute(str_query)
    self.con.commit()

    self.types = types</code></pre>
</details>
</dd>
<dt id="sql.SQLstore.put_artifacts"><code class="name flex">
<span>def <span class="ident">put_artifacts</span></span>(<span>self, artifacts)</span>
</code></dt>
<dd>
<div class="desc"><p>Primary function for insertion of artifact metadata into a defined schema</p>
<p><code>artifacts</code>: data_type derived class that has a regular structure of a defined schema, filled with rows to insert.</p>
<p><code>return</code>: none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_artifacts(self,artifacts):
    &#34;&#34;&#34;
    Primary function for insertion of artifact metadata into a defined schema

    `artifacts`: data_type derived class that has a regular structure of a defined schema, filled with rows to insert.

    `return`: none
    &#34;&#34;&#34;
    str_query = &#34;INSERT INTO &#34; + str(self.types.name) + &#34; VALUES ( &#34;
    for key, value in artifacts.properties.items():
        if key == &#39;file&#39;: # Todo, use this to detect str type
            str_query = str_query + &#34; &#39;&#34; + str(value) +&#34;&#39; &#34;
        else:
            str_query = str_query + &#34; &#34; + str(value)

        str_query = str_query +  &#34;,&#34;

    str_query = str_query.rstrip(&#39;,&#39;)
    str_query = str_query + &#34; )&#34;

    if isVerbose:
        print(str_query)
    
    self.cur.execute(str_query)
    self.con.commit()</code></pre>
</details>
</dd>
<dt id="sql.SQLstore.put_artifacts_csv"><code class="name flex">
<span>def <span class="ident">put_artifacts_csv</span></span>(<span>self, fname, tname)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for insertion of artifact metadata into a defined schema by using a CSV file, where the first row of the CSV
contains the column names of the schema. Any rows thereafter contain data to be inserted.</p>
<p><code>fname</code>: filepath to the .csv file to be read and inserted into the database</p>
<p><code>tname</code>: String name of the table to be inserted</p>
<p><code>return</code>: none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_artifacts_csv(self, fname, tname):
    &#34;&#34;&#34;
    Function for insertion of artifact metadata into a defined schema by using a CSV file, where the first row of the CSV
    contains the column names of the schema. Any rows thereafter contain data to be inserted.

    `fname`: filepath to the .csv file to be read and inserted into the database

    `tname`: String name of the table to be inserted

    `return`: none
    &#34;&#34;&#34;
    if isVerbose:
        print(&#34;Opening &#34; + fname)

    with open(fname) as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)
        line_count = 0
        for row in csv_reader:
            if line_count == 0:
                str_query = &#34;CREATE TABLE IF NOT EXISTS &#34; + str(tname) + &#34; ( &#34;
                for column in row:
                    str_query = str_query + str(column) + &#34; VARCHAR &#34;
                    str_query = str_query +  &#34;,&#34;

                str_query = str_query.rstrip(&#39;,&#39;)
                str_query = str_query + &#34; )&#34;

                if isVerbose:
                    print(str_query)
                
                self.cur.execute(str_query)
                self.con.commit()
                line_count += 1
            else:
                str_query = &#34;INSERT INTO &#34; + str(tname) + &#34; VALUES ( &#34;
                for column in row:
                    str_query = str_query + &#34; &#39;&#34; + str(column) + &#34;&#39;&#34;
                    str_query = str_query +  &#34;,&#34;

                str_query = str_query.rstrip(&#39;,&#39;)
                str_query = str_query + &#34; )&#34;

                if isVerbose:
                    print(str_query)
                
                self.cur.execute(str_query)
                self.con.commit()
                line_count += 1

        if isVerbose:        
            print(&#34;Read &#34; + str(line_count) + &#34; rows.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sql.SQLstore" href="#sql.SQLstore">SQLstore</a></code></h4>
<ul class="two-column">
<li><code><a title="sql.SQLstore.close" href="#sql.SQLstore.close">close</a></code></li>
<li><code><a title="sql.SQLstore.con" href="#sql.SQLstore.con">con</a></code></li>
<li><code><a title="sql.SQLstore.cur" href="#sql.SQLstore.cur">cur</a></code></li>
<li><code><a title="sql.SQLstore.filename" href="#sql.SQLstore.filename">filename</a></code></li>
<li><code><a title="sql.SQLstore.get_artifacts" href="#sql.SQLstore.get_artifacts">get_artifacts</a></code></li>
<li><code><a title="sql.SQLstore.put_artifact_type" href="#sql.SQLstore.put_artifact_type">put_artifact_type</a></code></li>
<li><code><a title="sql.SQLstore.put_artifacts" href="#sql.SQLstore.put_artifacts">put_artifacts</a></code></li>
<li><code><a title="sql.SQLstore.put_artifacts_csv" href="#sql.SQLstore.put_artifacts_csv">put_artifacts_csv</a></code></li>
<li><code><a title="sql.SQLstore.types" href="#sql.SQLstore.types">types</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>